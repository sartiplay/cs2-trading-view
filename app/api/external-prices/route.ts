import { type NextRequest, NextResponse } from "next/server";
import { scrapeCSGOSkinsPrice, scrapeMultipleCSGOSkinsPrices } from "@/lib/csgoskins-scraper.server";
import { addExternalPriceData, getExternalPriceData, getAllExternalPriceData } from "@/lib/external-data-storage.server";
import { startWorkerTask, updateWorkerTaskProgress, completeWorkerTask } from "@/lib/worker-storage.server";

export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const marketHashName = searchParams.get("market_hash_name");

    if (marketHashName) {
      // Get single item price
      const externalData = await getExternalPriceData(marketHashName);
      if (externalData) {
        return NextResponse.json(externalData);
      } else {
        return NextResponse.json(
          { error: "No external price data found for this item" },
          { status: 404 }
        );
      }
    } else {
      // Get all external price data
      const allData = await getAllExternalPriceData();
      return NextResponse.json(allData);
    }
  } catch (error) {
    console.error("Failed to fetch external price data:", error);
    return NextResponse.json(
      { error: "Failed to fetch external price data" },
      { status: 500 }
    );
  }
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { market_hash_name, market_hash_names } = body;

    if (market_hash_name) {
      // Scrape single item
      console.log(`[External Prices API] Scraping single item: ${market_hash_name}`);
      
      const scrapedData = await scrapeCSGOSkinsPrice(market_hash_name);
      if (scrapedData) {
        const externalData = {
          id: "", // Will be generated by addExternalPriceData
          market_hash_name,
          current_price: scrapedData.currentPrice,
          currency: scrapedData.currency,
          source: "csgoskins.gg" as const,
          last_updated: new Date().toISOString(),
          url: `https://csgoskins.gg/items/${market_hash_name.toLowerCase().replace(/\s+/g, '-')}`,
          price_change_24h: scrapedData.priceChange24h,
          price_change_24h_percent: scrapedData.priceChange24hPercent,
          trading_volume_24h: scrapedData.tradingVolume24h,
          market_cap: scrapedData.marketCap,
          week_low: scrapedData.weekLow,
          week_high: scrapedData.weekHigh,
          month_low: scrapedData.monthLow,
          month_high: scrapedData.monthHigh,
          year_low: scrapedData.yearLow,
          year_high: scrapedData.yearHigh,
          all_time_low: scrapedData.allTimeLow,
          all_time_high: scrapedData.allTimeHigh,
          popularity: scrapedData.popularity,
          community_rating: scrapedData.communityRating,
          votes: scrapedData.votes,
        };

        await addExternalPriceData(externalData);

        return NextResponse.json({
          success: true,
          data: externalData,
          message: `Successfully scraped price for ${market_hash_name}`,
        });
      } else {
        return NextResponse.json(
          { error: "Failed to scrape price data" },
          { status: 400 }
        );
      }
    } else if (market_hash_names && Array.isArray(market_hash_names)) {
      // Scrape multiple items
      console.log(`[External Prices API] Scraping ${market_hash_names.length} items`);
      
      // Start worker task
      const taskId = await startWorkerTask(
        "external_price_fetch",
        "Fetching External Prices",
        `Scraping prices for ${market_hash_names.length} items from CSGOSKINS.GG`,
        { totalItems: market_hash_names.length }
      );
      
      try {
        const scrapedData = await scrapeMultipleCSGOSkinsPrices(market_hash_names);
        const results = [];

        for (let i = 0; i < market_hash_names.length; i++) {
          const marketHashName = market_hash_names[i];
          const data = scrapedData.get(marketHashName);
          
          // Update progress
          await updateWorkerTaskProgress(taskId, { current: i + 1, total: market_hash_names.length });
          
          if (data) {
        const externalData = {
          id: "", // Will be generated by addExternalPriceData
          market_hash_name: marketHashName,
          current_price: data.currentPrice,
          currency: data.currency,
          source: "csgoskins.gg" as const,
          last_updated: new Date().toISOString(),
          url: `https://csgoskins.gg/items/${marketHashName.toLowerCase().replace(/\s+/g, '-')}`,
          price_change_24h: data.priceChange24h,
          price_change_24h_percent: data.priceChange24hPercent,
          trading_volume_24h: data.tradingVolume24h,
          market_cap: data.marketCap,
          week_low: data.weekLow,
          week_high: data.weekHigh,
          month_low: data.monthLow,
          month_high: data.monthHigh,
          year_low: data.yearLow,
          year_high: data.yearHigh,
          all_time_low: data.allTimeLow,
          all_time_high: data.allTimeHigh,
          popularity: data.popularity,
          community_rating: data.communityRating,
          votes: data.votes,
        };

        await addExternalPriceData(externalData);
            results.push(externalData);
          }
        }

        // Complete worker task
        await completeWorkerTask(taskId, true);

        return NextResponse.json({
          success: true,
          data: results,
          message: `Successfully scraped prices for ${results.length}/${market_hash_names.length} items`,
          scraped_count: results.length,
          total_count: market_hash_names.length,
        });
      } catch (error) {
        // Complete worker task with error
        await completeWorkerTask(taskId, false, error instanceof Error ? error.message : String(error));
        throw error;
      }
    } else {
      return NextResponse.json(
        { error: "market_hash_name or market_hash_names is required" },
        { status: 400 }
      );
    }
  } catch (error) {
    console.error("Failed to scrape external prices:", error);
    return NextResponse.json(
      { error: "Failed to scrape external prices" },
      { status: 500 }
    );
  }
}

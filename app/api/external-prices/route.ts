import { type NextRequest, NextResponse } from "next/server";
import { scrapeCSGOSkinsPrice, scrapeMultipleCSGOSkinsPrices } from "@/lib/csgoskins-scraper.server";
import { scrapeSkinsMonkeyPrice, scrapeMultipleSkinsMonkeyPrices } from "@/lib/skinsmonkey-scraper.server";
import { addExternalPriceData, getExternalPriceData, getAllExternalPriceData } from "@/lib/external-data-storage.server";
import { startWorkerTask, updateWorkerTaskProgress, completeWorkerTask } from "@/lib/worker-storage.server";

// URL conversion function to match the scraper's URL format
function convertMarketHashNameToURL(marketHashName: string): string {
  // Convert Steam market hash name to CSGOSKINS.GG URL format
  // Examples:
  // "★ Survival Knife" -> "survival-knife-vanilla"
  // "USP-S | Black Lotus" -> "usp-s-black-lotus"
  // "M4A1-S | Black Lotus (Field-Tested)" -> "m4a1-s-black-lotus"
  // "StatTrak™ AK-47 | Redline (Minimal Wear)" -> "ak-47-redline"
  
  // Remove rarity indicators (★, StatTrak™, Souvenir, etc.)
  let cleanName = marketHashName
    .replace(/★\s*/g, '') // Remove star symbol
    .replace(/StatTrak™\s*/g, '') // Remove StatTrak™
    .replace(/Souvenir\s*/g, '') // Remove Souvenir
    .replace(/★\s*/g, '') // Remove any remaining stars
    .trim();

  // Remove wear condition from parentheses (we don't need it in the URL)
  cleanName = cleanName.replace(/\s*\([^)]+\)\s*/, '').trim();

  // Convert to URL format
  let url = cleanName
    .toLowerCase()
    .replace(/\s*\|\s*/g, '-') // Replace pipe with dash
    .replace(/\s+/g, '-') // Replace spaces with dashes
    .replace(/[^\w\-]/g, '') // Remove special characters except dashes
    .replace(/-+/g, '-') // Replace multiple dashes with single dash
    .replace(/^-|-$/g, ''); // Remove leading/trailing dashes

  // For items without wear conditions, add "vanilla" for knives and some other items
  if (url.includes('knife') || url.includes('glove')) {
    url += '-vanilla';
  }

  return `https://csgoskins.gg/items/${url}`;
}

export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const marketHashName = searchParams.get("market_hash_name");
    const source = searchParams.get("source") as "csgoskins.gg" | "skinsmonkey" | null;

    if (marketHashName) {
      // Get single item price, optionally filtered by source
      const externalData = await getExternalPriceData(marketHashName, source || undefined);
      if (externalData) {
        return NextResponse.json(externalData);
      } else {
        return NextResponse.json(
          { error: "No external price data found for this item" },
          { status: 404 }
        );
      }
    } else {
      // Get all external price data
      const allData = await getAllExternalPriceData();
      return NextResponse.json(allData);
    }
  } catch (error) {
    console.error("Failed to fetch external price data:", error);
    return NextResponse.json(
      { error: "Failed to fetch external price data" },
      { status: 500 }
    );
  }
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { market_hash_name, market_hash_names, source = "csgoskins.gg" } = body;

    if (market_hash_name) {
      // Scrape single item
      console.log(`[External Prices API] Scraping single item: ${market_hash_name} from ${source}`);
      
      let externalData;
      
      if (source === "skinsmonkey") {
        const scrapedData = await scrapeSkinsMonkeyPrice(market_hash_name);
        if (scrapedData) {
          externalData = {
            id: "", // Will be generated by addExternalPriceData
            market_hash_name,
            trade_value: scrapedData.trade_value,
            currency: "USD",
            source: "skinsmonkey" as const,
            last_updated: new Date().toISOString(),
            url: scrapedData.url,
            offers_count: scrapedData.offers_count,
          };
        }
      } else {
        // Default to CSGOSKINS.GG
        const scrapedData = await scrapeCSGOSkinsPrice(market_hash_name);
        if (scrapedData) {
          externalData = {
            id: "", // Will be generated by addExternalPriceData
            market_hash_name,
            current_price: scrapedData.currentPrice,
            currency: scrapedData.currency,
            source: "csgoskins.gg" as const,
            last_updated: new Date().toISOString(),
            url: convertMarketHashNameToURL(market_hash_name),
            price_change_24h: scrapedData.priceChange24h,
            price_change_24h_percent: scrapedData.priceChange24hPercent,
            trading_volume_24h: scrapedData.tradingVolume24h,
            market_cap: scrapedData.marketCap,
            week_low: scrapedData.weekLow,
            week_high: scrapedData.weekHigh,
            month_low: scrapedData.monthLow,
            month_high: scrapedData.monthHigh,
            year_low: scrapedData.yearLow,
            year_high: scrapedData.yearHigh,
            all_time_low: scrapedData.allTimeLow,
            all_time_high: scrapedData.allTimeHigh,
            popularity: scrapedData.popularity,
            community_rating: scrapedData.communityRating,
            votes: scrapedData.votes,
          };
        }
      }

      if (externalData) {
        await addExternalPriceData(externalData);

        return NextResponse.json({
          success: true,
          data: externalData,
          message: `Successfully scraped price for ${market_hash_name} from ${source}`,
        });
      } else {
        return NextResponse.json(
          { error: "Failed to scrape price data" },
          { status: 400 }
        );
      }
    } else if (market_hash_names && Array.isArray(market_hash_names)) {
      // Scrape multiple items
      console.log(`[External Prices API] Scraping ${market_hash_names.length} items from ${source}`);
      
      // Start worker task
      const taskId = await startWorkerTask(
        "external_price_fetch",
        "Fetching External Prices",
        `Scraping prices for ${market_hash_names.length} items from ${source.toUpperCase()}`,
        { totalItems: market_hash_names.length }
      );
      
      try {
        let results = [];
        
        if (source === "skinsmonkey") {
          const scrapedData = await scrapeMultipleSkinsMonkeyPrices(market_hash_names);
          results = scrapedData.map((data) => ({
            id: "", // Will be generated by addExternalPriceData
            market_hash_name: data.market_hash_name,
            trade_value: data.trade_value,
            currency: "USD",
            source: "skinsmonkey" as const,
            last_updated: new Date().toISOString(),
            url: data.url,
            offers_count: data.offers_count,
          }));
        } else {
          // Default to CSGOSKINS.GG
          const scrapedData = await scrapeMultipleCSGOSkinsPrices(market_hash_names);
          results = [];
          
          for (let i = 0; i < market_hash_names.length; i++) {
            const marketHashName = market_hash_names[i];
            const data = scrapedData.get(marketHashName);
            
            // Update progress
            await updateWorkerTaskProgress(taskId, { current: i + 1, total: market_hash_names.length });
            
            if (data) {
              results.push({
                id: "", // Will be generated by addExternalPriceData
                market_hash_name: marketHashName,
                current_price: data.currentPrice,
                currency: data.currency,
                source: "csgoskins.gg" as const,
                last_updated: new Date().toISOString(),
                url: convertMarketHashNameToURL(marketHashName),
                price_change_24h: data.priceChange24h,
                price_change_24h_percent: data.priceChange24hPercent,
                trading_volume_24h: data.tradingVolume24h,
                market_cap: data.marketCap,
                week_low: data.weekLow,
                week_high: data.weekHigh,
                month_low: data.monthLow,
                month_high: data.monthHigh,
                year_low: data.yearLow,
                year_high: data.yearHigh,
                all_time_low: data.allTimeLow,
                all_time_high: data.allTimeHigh,
                popularity: data.popularity,
                community_rating: data.communityRating,
                votes: data.votes,
              });
            }
          }
        }

        // Save all results
        for (const externalData of results) {
          await addExternalPriceData(externalData);
        }

        // Complete worker task
        await completeWorkerTask(taskId, true);

        return NextResponse.json({
          success: true,
          data: results,
          message: `Successfully scraped prices for ${results.length}/${market_hash_names.length} items from ${source}`,
          scraped_count: results.length,
          total_count: market_hash_names.length,
        });
      } catch (error) {
        // Complete worker task with error
        await completeWorkerTask(taskId, false, error instanceof Error ? error.message : String(error));
        throw error;
      }
    } else {
      return NextResponse.json(
        { error: "market_hash_name or market_hash_names is required" },
        { status: 400 }
      );
    }
  } catch (error) {
    console.error("Failed to scrape external prices:", error);
    return NextResponse.json(
      { error: "Failed to scrape external prices" },
      { status: 500 }
    );
  }
}
